{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ActiMotus","text":"<p>A Python-powered human activity recognition algorithm building upon Acti4. It processes data from multiple accelerometers with a primary requirement for a thigh-worn sensor.</p> <ul> <li>Scientifically validated activity detection.</li> <li>Device-independent, relies on RAW accelerometry.</li> <li>Minimum Requirement: Single accelerometer worn on the thigh (front or side).</li> <li>Detects: Lying, sitting, standing, walking, stair climbing, and bicycling.</li> <li>Optional: A back-worn sensor enhances lying/sitting detection; a calf-worn sensor adds squatting/kneeling detection.</li> </ul>"},{"location":"#about-predecessor-acti4","title":"About predecessor Acti4","text":"<p>Developed by the Danish National Research Center for Working Environment (NRCWE), Acti4 was a MATLAB-based tool designed to classify physical activities (lying, sitting, standing, walking) and assess posture using sensors on the thigh, hip, arm, and trunk. It allowed for combining detections with participant diaries to analyze movement behavior during work and leisure. Development of Acti4 concluded in July 2020. Focus has since shifted to its Python-based successor, ActiMotus, which is being developed in partnership with SENS Innovation ApS and is the core of Motus infrastructure.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install using <code>pip install acti-motus</code>.</p>"},{"location":"#usage-example","title":"Usage example","text":"<p>To see ActiMotus in action, here is a simple workflow processing data from a single thigh-worn accelerometer.</p>"},{"location":"#1-load-the-raw-accelerometer-data","title":"1. Load the raw accelerometer data","text":"<pre><code>import pandas as pd\nfrom actimotus import Sens\n\n# Load binary data\nraw = Sens.from_bin(raw_thigh.bin)\nprint(raw)\n\ndatetime                           acc_x       acc_y       acc_z  \n2024-09-02 08:08:50.227000+00:00   0.218750   -0.171875   -0.773438\n2024-09-02 08:08:50.307000+00:00   0.257812   -0.203125   -0.937500\n2024-09-02 08:08:50.387000+00:00   0.242188   -0.226562   -0.953125\n2024-09-02 08:08:50.467000+00:00   0.234375   -0.242188   -0.945312\n2024-09-02 08:08:50.548000+00:00   0.257812   -0.226562   -0.953125\n</code></pre>"},{"location":"#2-extract-features-and-detect-activity-types","title":"2. Extract features and detect activity types","text":"<p>Next step is to extract features and detect activity types:</p> <pre><code>from actimotus import Features, Activities\n\n# Calculate features from the raw data\nfeatures = Features(calibrate=False).compute(df)\n\n# Classify activities\nacivities, references = Activities(vendor=\"Sens\").compute(features)\nprint(activities)\n\ndatetime                    activity  \n2024-09-02 08:08:51+00:00   sit\n2024-09-02 08:08:52+00:00   sit\n2024-09-02 08:08:53+00:00   sit\n2024-09-02 08:08:54+00:00   sit\n2024-09-02 08:08:55+00:00   sit\n</code></pre>"},{"location":"#3-generate-aggregated-exposures","title":"3. Generate aggregated exposures","text":"<p>To summarize the detected activities over time (e.g., daily totals), transform the data into exposures:</p> <pre><code>from actimotus import Exposures\n\n# Compute daily exposures from the activity data\nexposures = Exposures().compute(df)\nprint(exposures)\n\ndatetime                    sit               stand             walk              bicycle\n2024-09-02 00:00:00+00:00   0 days 04:13:20   0 days 02:29:48   0 days 01:43:48   0 days 00:00:00\n2024-09-03 00:00:00+00:00   0 days 07:20:48   0 days 02:23:44   0 days 01:42:22   0 days 00:17:35\n2024-09-04 00:00:00+00:00   0 days 08:16:13   0 days 02:24:17   0 days 00:54:27   0 days 00:37:01\n2024-09-05 00:00:00+00:00   0 days 00:44:01   0 days 00:38:16   0 days 00:10:19   0 days 00:17:27\n</code></pre> <p>Detailed information on ActiMotus processing and features is available in the learning center.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#231-2026-02-03","title":"[2.3.1] - 2026-02-03","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Trunk reference angle calculation: Updated the calculation logic to prevent errors when values fall outside the valid arccos domain. Inputs are now strictly clipped to the [-1, 1] range (radians) to ensure numerical stability.</li> <li>Refined activity mapping: Updated the fused activities mapping logic. <code>Standing</code>: No longer categorized as sedentary or LPA; it is now tracked as a standalone category. <code>Kneeling</code>: Now mapped as sedentary.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Exposures plot: Improved handling of timeline data to ensure consistent rendering and scaling.</li> <li>Project maintenance: Cleaned and optimized <code>pyproject.toml</code> and <code>.gitignore</code>.</li> </ul>"},{"location":"changelog/#230-2026-01-03","title":"2.3.0 - 2026-01-03","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>New activity type: fast-walking.</li> <li>Timeline visualization plot for Exposures.</li> <li>Option to fuse activity types into merged exposures.</li> <li>Initial data quality checks for Activities/Exposures (flags invalid data when combined duration of climbing + walking is less than 10 minutes in a specific window).</li> <li>Support for custom configuration of activity detection thresholds.</li> <li>Experimental: Context initialization for Exposures (diary handling).</li> <li>Initial project documentation.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Renamed package from <code>acti-motus</code> to <code>actimotus</code>.</li> <li>Updated Exposures generation logic to include fast-walking and other new categories.</li> <li>Improved feature extraction robustness regarding data gaps (handling missing data in raw accelerometer time series).</li> <li>Updated default configuration thresholds for activities.</li> <li>Adjusted orientation correction: Non-wear data is no longer flipped when flipping detection is enabled.</li> <li>Implemented new custom gravitational calibration algorithm.</li> <li>Updated docstrings.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Dependency: <code>scikit-digital-health</code> library.</li> </ul>"},{"location":"changelog/#220-2025-09-10","title":"2.2.0 - 2025-09-10","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Auto-calibration support using the Scikit Digital Health library.</li> <li>Parser for Sens binary files.</li> <li>Configuration option to set custom activity thresholds (for thigh and trunk sensors).</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Unified terminology: consistently use \"compute\" instead of generate/extract/etc.</li> <li>Updated wear-time detection algorithm (ongoing debugging).</li> <li>Renamed activity \"move\" \u2192 \"shuffle\".</li> <li>Updated default activity thresholds based on recent validation studies (use LEGACY_CONFIG for Acti4 threshold compatibility).</li> <li>Improved flipping detection functions to handle edge cases more robustly by refining detection thresholds.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Corrected bug where non-wear time was not counted properly in the Exposures report.</li> <li>Added default stairs threshold when no data-based threshold is available.</li> <li>Fixed return values for inside-out flip detection for trunk sensors.</li> <li>Corrected chunking procedure: only acceleration axes are propagated (removed unintended overlapping column).</li> <li>Improved inside-out flipping detection for thigh sensors, reducing false positives and increasing accuracy.</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>Default logger.</li> <li>Multithreaded processing.</li> </ul>"},{"location":"contributing/","title":"Contributing to ActiMotus","text":"<p>We'd love you to contribute to ActiMotus!</p> <p>Questions, feature requests, and bug reports are all welcome as GitHub Discussions or Issues.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>Since the project is currently a work-in-progress, we are figuring out the best workflows as we go. If you submit a Pull Request, we will review it and guide you through any changes needed. Don't worry about getting it perfect the first time\u2014let's build this together!</p>"},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11 or higher.</li> <li>uv for dependency and environment management.</li> <li>git for version control.</li> </ul>"},{"location":"contributing/#installation-and-setup","title":"Installation and Setup","text":"<ol> <li> <p>Fork and Clone. Fork the repository on GitHub and clone your fork locally: <pre><code>git clone git@github.com:&lt;your-username&gt;/actimotus.git\ncd actimotus\n</code></pre></p> </li> <li> <p>Install uv. If you don't have it yet, install uv following the official guide.</p> </li> <li> <p>Install Dependencies. Run the sync command to create the virtual environment and install all dependencies (including dev, test, and doc tools): <pre><code>uv sync\n</code></pre></p> </li> <li> <p>Check out a new branch. Create a new branch for your changes: <pre><code>git checkout -b my-new-feature-branch\n# Make your changes...\n</code></pre></p> </li> <li> <p>Run Tests and Linting. Please run the checks locally to ensure the code is formatted correctly. <pre><code># Run pre-commit checks on all files\nuv run pre-commit\n</code></pre></p> </li> </ol>"},{"location":"learn/processing/","title":"Processing","text":"<p>This section is a work-in-progress. To check usage examples, please see the example notebooks.</p>"},{"location":"references/activities/","title":"Activities","text":""},{"location":"references/activities/#actimotus.Activities","title":"actimotus.Activities  <code>dataclass</code>","text":"<p>Processes extracted features to perform Human Activity Recognition (HAR).</p> <p>This class ingests features from multiple sensors (required: thigh; optional: trunk, calf, arm) and produces a time-series of recognized activities at 1-second resolution.</p> <p>Key capabilities include automatic sensor orientation detection (correcting for upside-down or inside-out flipped devices), vendor-specific signal corrections, and configurable activity recognition thresholds.</p> <p>Attributes:</p> Name Type Description <code>system_frequency</code> <code>int</code> <p>The target frequency (in Hz) used for internal calculations. Defaults to 30 Hz.</p> <code>vendor</code> <code>Literal['Sens', 'Other']</code> <p>The hardware vendor of the sensor. If set to <code>'Sens'</code>, specific signal corrections are applied. Use <code>'Other'</code> for generic devices.</p> <code>orientation</code> <code>bool</code> <p>If <code>True</code>, automatically detects and corrects the sensor orientation (e.g., if the device was worn upside down).</p> <code>chunks</code> <code>bool</code> <p>If <code>True</code>, processes data in overlapping chunks to simulate cloud/streaming infrastructure.</p> <code>size</code> <code>str | timedelta</code> <p>The duration of each processing chunk. Accepts a <code>timedelta</code> object or a pandas-style string alias (e.g., <code>'1d'</code>, <code>'1h'</code>).</p> <code>overlap</code> <code>str | timedelta</code> <p>The duration of overlap between consecutive chunks. Accepts a <code>timedelta</code> object or a string alias (e.g., <code>'15min'</code>).</p> <code>config</code> <code>dict[str, Any] | Literal['DEFAULT', 'LEGACY']</code> <p>The configuration for activity recognition thresholds. Can be a dictionary of custom parameters, or a preset string:</p> <ul> <li><code>'DEFAULT'</code>: Standard thresholds for general population.</li> <li><code>'LEGACY'</code>: Older threshold values for backward compatibility.</li> </ul> <p>Examples:</p> <p>Standard usage with default configuration:</p> <pre><code>&gt;&gt;&gt; model = Activities()\n&gt;&gt;&gt; # activities, references = model.process(features)\n</code></pre> <p>Usage for 'Sens' devices with legacy thresholds and automatic flip detection:</p> <pre><code>&gt;&gt;&gt; model = Activities(\n...     vendor='Sens',\n...     config='LEGACY',\n...     orientation=True\n... )\n</code></pre>"},{"location":"references/activities/#actimotus.Activities.compute","title":"compute","text":"<pre><code>compute(\n    thigh: DataFrame,\n    *,\n    trunk: DataFrame | None = None,\n    calf: DataFrame | None = None,\n    arm: DataFrame | None = None,\n    references: dict[str, Any] | None = None\n) -&gt; tuple[pd.DataFrame, dict[str, Any]]\n</code></pre> <p>Executes the activity recognition pipeline on the provided sensor data.</p> <p>This method synchronizes inputs from the thigh (primary) and optional secondary sensors.</p> <p>Parameters:</p> Name Type Description Default <code>thigh</code> <code>DataFrame</code> <p>The primary accelerometer feature data. Must contain a <code>DatetimeIndex</code>. This sensor is mandatory for the pipeline.</p> required <code>trunk</code> <code>DataFrame | None</code> <p>Optional feature data from a trunk sensor.</p> <code>None</code> <code>calf</code> <code>DataFrame | None</code> <p>Optional feature data from a calf sensor.</p> <code>None</code> <code>arm</code> <code>DataFrame | None</code> <p>Optional feature data from an arm sensor.</p> <code>None</code> <code>references</code> <code>dict[str, Any] | None</code> <p>A dictionary containing reference data (individual reference angles, calibration intervals).</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A tuple <code>(activities, updated_references)</code> containing:</p> <code>dict[str, Any]</code> <ol> <li>activities (<code>pd.DataFrame</code>): The recognized activities, resampled to 1-second epochs.</li> </ol> <code>tuple[DataFrame, dict[str, Any]]</code> <ol> <li>updated_references (<code>dict</code>): The updated state dictionary, containing new reference angles calculated during processing.</li> </ol> <p>Examples:</p> <p>Basic usage with only the mandatory thigh sensor:</p> <pre><code>&gt;&gt;&gt; model = Activities()\n&gt;&gt;&gt; activities, references = model.compute(features)\n</code></pre> <p>Usage with multiple sensors and existing references. Note that secondary sensors must be passed as keyword arguments:</p> <pre><code>&gt;&gt;&gt; previous_references = {\n...     'thigh': {\n...         'value': -0.201,\n...         'expires': '2024-09-03 12:05:51+00:00',\n...     },\n...     'calibrations': [\n...         {\n...             'start': '2024-09-03 08:08:51+00:00',\n...             'end': '2024-09-03 08:09:11+00:00',\n...             'ttl': '24h',\n...         },\n...     ],\n... }\n&gt;&gt;&gt; activities, new_references = model.compute(\n...     thigh_df,\n...     trunk=trunk_df,\n...     references=previous_references,\n... )\n</code></pre>"},{"location":"references/exposures/","title":"Exposures","text":""},{"location":"references/exposures/#actimotus.Exposures","title":"actimotus.Exposures  <code>dataclass</code>","text":"<p>Aggregates activity data into summary exposure metrics.</p> <p>This class takes the 1-second activity epochs (produced by <code>Activities</code>) and calculates aggregate exposure metrics over a specified time window. Metrics include total time spent in specific postures (e.g., Sedentary, MVPA), and frequency of transitions (e.g., sit-to-stand) and also data quality check indicating invalid data.</p> <p>It supports generating results as raw DataFrame or visual plot.</p> <p>Attributes:</p> Name Type Description <code>window</code> <code>str | timedelta</code> <p>The time window for aggregation. Accepts a <code>timedelta</code> object or a pandas-style string offset (e.g., <code>'1d'</code> for daily totals, <code>'1h'</code> for hourly). Defaults to daily aggregation.</p> <code>fused</code> <code>bool</code> <p>If <code>True</code>, granular activity categories are merged into broader semantic groups before calculation. This simplifies the output by combining physiologically similar states.</p> <p>Fusion Mappings:</p> <ul> <li>Sedentary: Combines lie, sit, and kneel.</li> <li>Standing: Combines stand, squat, and shuffle.</li> <li>Walking: Combines walk, fast-walk, and stairs climbing.</li> </ul> <p>Examples:</p> <p>Standard daily exposures with full granular categories:</p> <pre><code>&gt;&gt;&gt; exposures = Exposures()\n&gt;&gt;&gt; # results = exposures.compute(activities)\n</code></pre> <p>Weekly exposures with fused categories (grouping all walking types):</p> <pre><code>&gt;&gt;&gt; exposures = Exposures(window='7d', fused=True)\n</code></pre>"},{"location":"references/exposures/#actimotus.Exposures.compute","title":"compute","text":"<pre><code>compute(df: DataFrame) -&gt; pd.DataFrame\n</code></pre> <p>Calculates exposure metrics and validity flags for the given activity data.</p> <p>This method aggregates the input time-series based on the configured <code>window</code> size (e.g., daily). It computes durations for each activity category and determines if the monitoring period is considered \"valid.\"</p> <p>Validity Criteria: A window is marked as <code>valid</code> (True) if the subject performed at least 10 minutes of active movement (Stairs + Walk) within that period.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A DataFrame containing 1-second activity epochs. It must be indexed by a <code>DatetimeIndex</code> and contain an <code>'activity'</code> column.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame indexed by the time window (e.g., each day), containing:</p> <code>DataFrame</code> <ul> <li>valid: Boolean flag indicating if the window met the activity threshold.</li> </ul> <code>DataFrame</code> <ul> <li>[Activity Names]: Columns for each activity type (e.g., 'sit', 'stand', 'walk'), containing the total duration (<code>timedelta</code>) spent in that state.</li> </ul> <code>DataFrame</code> <ul> <li>[Fused Categories]: If <code>fused=True</code>, contains broader categories like 'sedentary' instead of granular ones.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; exposures = Exposures(window='1d', fused=False)\n&gt;&gt;&gt; results = exposures.compute(activity_epochs_df)\n</code></pre>"},{"location":"references/exposures/#actimotus.Exposures.plot","title":"plot","text":"<pre><code>plot(\n    df: DataFrame, language: dict[str, Any] | None = None\n) -&gt; alt.Chart\n</code></pre> <p>Generates an interactive Gantt-style chart of the activity timeline.</p> <p>This method visualizes the 1-second activity epochs. If <code>fused</code> is enabled on this instance, the plot will automatically group similar activities (e.g., 'walk', 'stairs' -&gt; 'Walking') and use the simplified color scheme.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The input DataFrame containing 1-second activity epochs. Must contain an <code>'activity'</code> column.</p> required <code>language</code> <code>dict[str, Any] | None</code> <p>A configuration dictionary to customize chart labels and colors (e.g., for localization). If <code>None</code>, defaults to the standard English configuration.</p> <code>None</code> <p>Returns:</p> Type Description <code>Chart</code> <p>An Altair Chart object representing the activity timeline. To display it in a notebook, simply let the object return or call <code>.display()</code>.</p> <p>Examples:</p> <p>Basic usage with default English labels:</p> <pre><code>&gt;&gt;&gt; chart = exposures.plot(df)\n&gt;&gt;&gt; chart.save('timeline.html')\n</code></pre>"},{"location":"references/exposures/#actimotus.Exposures.context","title":"context  <code>staticmethod</code>","text":"<pre><code>context(\n    df: DataFrame,\n    intervals: DataFrame,\n    context: str,\n    activities: list[str] | None = None,\n) -&gt; pd.Series\n</code></pre>"},{"location":"references/features/","title":"Features","text":""},{"location":"references/features/#actimotus.Features","title":"actimotus.Features  <code>dataclass</code>","text":"<p>Processes raw accelerometer data to extract features.</p> <p>This class provides a pipeline for transforming raw accelerometer time-series data into a set of features. The process includes input validation, sampling frequency detection, resampling, optional auto-calibration, and the computation of metrics (e.g., High-Low ratio, step-related metrics).</p> <p>The class can process data in a single batch or in overlapping chunks to mimic Sens's infrastructure.</p> <p>Attributes:</p> Name Type Description <code>system_frequency</code> <code>int</code> <p>The target frequency (in Hz) to which data is resampled. Warning: Defaults to 30 Hz. Changing this is not recommended as downstream pipelines depend on this frequency.</p> <code>validation</code> <code>bool</code> <p>If <code>True</code>, performs schema and format validation on the input.</p> <code>calibrate</code> <code>bool</code> <p>If <code>True</code>, applies gravitational auto-calibration to the raw data.</p> <code>chunking</code> <code>bool</code> <p>If <code>True</code>, processes the data in overlapping chunks.</p> <code>size</code> <code>timedelta</code> <p>The duration of each data chunk. Only used if <code>chunking</code> is <code>True</code>.</p> <code>overlap</code> <code>timedelta</code> <p>The duration of overlap between consecutive chunks. Only used if <code>chunking</code> is <code>True</code>.</p> <p>Examples:</p> <p>Basic usage with default settings:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; extractor = Features()\n&gt;&gt;&gt; # features = extractor.compute(df)\n</code></pre> <p>Configuration for chunked processing:</p> <pre><code>&gt;&gt;&gt; extractor = Features(\n...     chunking=True,\n...     size=timedelta(days=1),\n...     overlap=timedelta(minutes=15)\n... )\n</code></pre>"},{"location":"references/features/#actimotus.Features.compute","title":"compute","text":"<pre><code>compute(\n    df: DataFrame, sampling_frequency: float | None = None\n) -&gt; pd.DataFrame\n</code></pre> <p>Computes extracted features from raw accelerometer data.</p> <p>This method orchestrates the pipeline: it handles format validation, frequency inference, resampling, and optional calibration. It then dispatches the computation to either a chunked or batch processing backend based on the instance configuration.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The input DataFrame containing accelerometer data. Must possess a <code>DatetimeIndex</code> and contain only accelerometer columns (axes X, Y, Z).</p> required <code>sampling_frequency</code> <code>float | None</code> <p>The sampling frequency of the data in Hertz. If <code>None</code>, it is inferred automatically from the index of <code>df</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing the computed features.</p> <p>Examples:</p> <p>Basic usage where frequency is inferred:</p> <pre><code>&gt;&gt;&gt; extractor = Features()\n&gt;&gt;&gt; features = extractor.compute(df)\n</code></pre> <p>Explicitly providing frequency:</p> <pre><code>&gt;&gt;&gt; features = extractor.compute(df, sampling_frequency=12.5)\n</code></pre>"},{"location":"references/parsers/","title":"Parsers","text":""},{"location":"references/parsers/#actimotus.Sens","title":"actimotus.Sens  <code>dataclass</code>","text":"<p>Parses SENS accelerometer data from binary files.</p> <p>This class handles the extraction of raw accelerometer data from SENS <code>.bin</code> files. It reads the binary structure, validates the file format, and optionally normalizes the raw integer values to gravitational units (g).</p> <p>Attributes:</p> Name Type Description <code>normalize</code> <code>bool</code> <p>If <code>True</code>, raw values are multiplied by the normalization factor (<code>-4/512</code>) to convert them to g-force. If <code>False</code>, returns the raw integer counts from the sensor ADC. Defaults to <code>True</code>.</p>"},{"location":"references/parsers/#actimotus.Sens.from_bin","title":"from_bin","text":"<pre><code>from_bin(path: str | Path) -&gt; pd.DataFrame\n</code></pre> <p>Reads and decodes a Sens binary file into a DataFrame.</p> <p>This method validates the file extension and existence before parsing. It handles path conversion automatically.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The file path to the source <code>.bin</code> file. Accepts either a string path or a <code>Path</code> object.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing the parsed accelerometer data. If <code>normalize</code></p> <code>DataFrame</code> <p>is <code>True</code>, the data is in g; otherwise, it is in raw units.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; parser = Sens(normalize=True)\n&gt;&gt;&gt; df = parser.from_bin(\"data/sensor_01.bin\")\n</code></pre>"}]}